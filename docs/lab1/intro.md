# 背景

操作系统是一个软件，也需要通过某种机制加载并运行它。对于LoongArch32的计算机来说，上电复位最初启动的是一个BIOS软件（例如PMON），该BIOS软件能够支持从网络加载ELF格式的操作系统内核，从而开始启动我们已经编译好的uCore内核。

而对于QEMU虚拟机而言，我们可以直接使用`-kernel`来指定我们需要加载的内核的ELF文件，从而直接完成了内核的载入过程，并直接从ELF的入口点开始启动。

## BIOS启动过程

当计算机加电后，一般不直接执行操作系统，而是执行系统初始化软件完成基本IO初始化和引导加载功能。简单地说，系统初始化软件就是在操作系统内核运行之前运行的一段小软件。通过这段小软件，我们可以初始化硬件设备、建立系统的内存空间映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。最终引导加载程序把操作系统内核映像加载到RAM中，并将系统控制权传递给它。

对于绝大多数计算机系统而言，操作系统和应用软件是存放在磁盘（硬盘/软盘）、光盘、EPROM、ROM、Flash等可在掉电后继续保存数据的存储介质上。计算机启动后，CPU一开始会到一个特定的地址开始执行指令，这个特定的地址存放了系统初始化软件，负责完成计算机基本的IO初始化，这是系统加电后运行的第一段软件代码。

对于LoongArch32体系结构而言，真实的硬件上电后会开始启动BIOS，该BIOS可以被自己刷写。而在[ChipLab教学计算机](https://gitee.com/loongson-edu/chiplab)中采用的是PMON2000作为BIOS，它具有网络功能，可以通过网卡从网络上使用tftp协议载入ELF格式的操作系统内核加载到内存，然后从ELF的入口点启动。

而我们实验采用的QEMU环境，则是抛弃了BIOS这一过程。在QEMU上直接使用`-kernel`参数指定内核的ELF文件，本质上就是完成了BIOS所做的加载内核的过程，直接从ELF文件的入口点开始启动操作系统。

### 操作系统启动过程

当bootloader通过把ucore在系统加载到内存后，就转跳到ucore操作系统在内存中的入口位置（kern/start.S中的start的地址），这样ucore就接管了整个控制权。当前的ucore功能很简单，只完成基本的内存管理和外设中断管理。ucore主要完成的工作包括：

- 配置DMW，使得操作系统拥有可用的地址空间（位于`kern/init/entry.S`，其它部分均为C语言程序，整体位于`kern/init/init.c`）
- 初始化终端；
- 显示字符串；
- 设置例外两个例外向量；
- 执行while（1）死循环。

以后的实验中会大量涉及各个函数直接的调用关系，以及由于中断处理导致的异步现象，可能对大家实现操作系统和改正其中的错误有很大影响。而理解好函数调用关系的建立机制和中断处理机制，对后续实验会有很大帮助。

### 地址空间

uCore中的地址空间涉及两种地址：

- 逻辑地址（Logical Address,应用程序员看到的地址，在操作系统原理上称为虚拟地址，以后提到虚拟地址就是指逻辑地址）

- 物理地址（Physical Address, 实际的物理内存地址）。

(1) 逻辑地址空间

从应用程序的角度看，逻辑地址空间就是应用程序员编程所用到的地址空间，比如下面的程序片段：

    int val=100;

    int * point=&val;

其中指针变量point中存储的即是一个逻辑地址。

(2) 物理地址空间

从操作系统的角度看，CPU、内存硬件（通常说的“内存条”）和各种外设是它主要管理的硬件资源而内存硬件和外设分布在物理地址空间中。物理地址空间就是一个“大数组”，CPU通过索引（物理地址）来访问这个“大数组”中的内容。物理地址是指CPU提交到内存总线上用于访问计算机内存和外设的最终地址。

物理地址空间的大小取决于CPU实现的物理地址位数，LoongArch32计算机中，CPU的物理地址空间取决于处理器配置的PALEN。而对于外设，则是固定配置于0x1f000000~0x1fffffff。例如我们如果配置QEMU的内存为256M，那么物理地址空间如下：

```
    +------------------+  <- 0xFFFFFFFF (4GB)
    |     无效空间      |
    +------------------+  <- 0x1FFFFFFF (512M)
    |   IO外设地址空间   |
    +------------------+  <- 0x1F000000 (496M)
    |     无效空间      |
    +------------------+  <- 0x0FFFFFFF (256M)
    |     有效内存      |
    +------------------+  <- 0x00000000
```

#### 中断与异常

操作系统需要对计算机系统中的各种外设进行管理，这就需要CPU和外设能够相互通信才行。一般外设的速度远慢于CPU的速度。如果让操作系统通过CPU“主动关心”外设的事件，即采用通常的轮询(polling)机制，则太浪费CPU资源了。所以需要操作系统和CPU能够一起提供某种机制，让外设在需要操作系统处理外设相关事件的时候，能够“主动通知”操作系统，即打断操作系统和应用的正常执行，让操作系统完成外设的相关处理，然后再恢复操作系统和应用的正常执行。在操作系统中，这种机制称为中断机制。中断机制给操作系统提供了处理意外情况的能力，同时它也是实现进程/线程抢占式调度的一个重要基石。但中断的引入会导致对操作系统的理解更加困难。

在LoongArch32架构中，中断属于异常(Exception)的一种，uCore内核目前处理的异常包括以下类型：

- 中断          (EX_IRQ,CSR.ESTAT.Ecode=0)

- Load操作页无效 (EX_TLBL,CSR.ESTAT.Ecode=1)

- Store操作页无效(EX_TLBS,CSR.ESTAT.Ecode=2)

- TLB 重填      (EX_TLBR,CSR.ESTAT.Ecode=31)

- 指令不存在     (EX_RI,CSR.ESTAT.Ecode=13)

- 指令特权等级错误(EX_IPE,CSR.ESTAT.Ecode=14)

- 系统调用       (EX_SYS,CSR.ESTAT.Ecode=11)

- 地址错误例外    (EX_ADE,CSR.ESTAT.Ecode=8) 例如地址没有对齐

LoongArch32架构的处理器也提供了两个例外入口。分别是常规例外与TLB例外。由于TLB例外涉及重填页表的工作，因此必须为物理地址。而常规例外入口则可以根据目前处理器的运行状态选择使用虚拟地址或物理地址。

**注意：这里我们所使用的QEMU在直接地址翻译模式下，会抹除CSR.RFBASE地址的高3位，因此我们不需要关心TLB重填时地址访问的地址的问题，可以直接修改CSR.CRMD来开启映射地址翻译模式，然后当做虚拟地址一样处理即可。**

这两个例外入口也存储在CSR寄存器中，名称分别为CSR.EBASE与CSR.RFBASE。当例外产生时，处理器会进行如下操作：

- 将CSR.CRMD的PLV、IE分别存到CSR.PRMD的PPLV和IE中，然后将CSR.CRMD的PLV置为0，IE置为0。

- 将触发例外指令的PC值记录到CSR.ERA中

- 跳转到例外入口处取值。（如果是TLB相关例外跳转到CSR.RFBASE，否则为CSR.EBASE）

然后将PC跳转到对应的例外入口地址处，交给软件完成例外的处理操作。

当例外处理结束后，软件应该执行ERTN从例外状态返回，该指令会完成如下操作：

- 将CSR.PRMD中的PPLV、PIE值回复到CSR.CRMD的PLV、IE中。

- 跳转到CSR.ERA所记录的地址处取指。